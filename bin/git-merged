#!/usr/bin/env bash

set -euo pipefail
VERBOSE="${VERBOSE:-1}"
DEBUG="${DEBUG:-0}"

verbose() { enabled VERBOSE || debugging; }
_log() { if terminal; then echo "$*" 1>&2; fi; }
_print() { echo -n "$*" 1>&2; }
# terminal returns true if we're attached to a terminal.
terminal() { [[ -t 1 ]]; }
log() { verbose && _log "$*"; }
# log_output writes one line. The first arg is on stderr, the remaining on stdout.
log_output() { if terminal; then _print "$1"; fi; shift; echo "$*"; }
die() { _log "FATAL: $*"; exit 1; }
debugging() { enabled DEBUG; }
debug() { if debugging; then _log "DEBUG: $*"; fi; }
enabled() { [[ "${!1:-,,}" =~ 1|true|y|yes ]]; }
run() {
	debug "Running $*"
	if ! "$@"; then
		_log "Command failed: $*"
	fi
}

is_in_array() { local WHAT="$1"; shift
	for E; do [[ "$E" == "$WHAT" ]] && return 0; done
	return 1
}

GIT_DIR="${GIT_DIR:-.git}"

print_branch_if_exists() { local NAME="$1"
	[[ -f "$GIT_DIR/refs/heads/$NAME" ]] || return 1
	echo "$NAME"
}

remote_default_branch() { local REMOTE_NAME="$1"
	[[ -z "$REMOTE_NAME" ]] && return 0
	git remote show "$REMOTE_NAME" | grep 'HEAD branch' | cut -d':' -f2 | xargs	
}

print_remote_if_exists() { NAME="$1"
	git remote | grep -E "^$NAME\$" || return 1
}

# Try to figure out the default remote.
default_remote() { local REMOTES= COUNT
	read -ra REMOTES < <(git remote) || return 0
	COUNT=${#REMOTES}
	[[ $COUNT -eq 1 ]] && { echo "${REMOTES[0]}"; return; }
	# Look for the commonest remote name...
	print_remote_if_exists origin && return
	[[ $COUNT -eq 0 ]] && return
	# Just pick the first remote in the list... YOLO
	echo "${REMOTES[0]}"
}

default_target_branch() {
	# Look for some common default branch names...
	print_branch_if_exists main   && return
	print_branch_if_exists master && return
	# Query deafult remote
	remote_default_branch "$(default_remote)"
}

TARGET_BRANCH="${1:-$(default_target_branch)}"

# MERGED_LIST contains branches that have actually been merged.
MERGED_LIST="$(git branch --merged "$TARGET_BRANCH" --format='%(refname:lstrip=2)' | grep -Ev "^$TARGET_BRANCH\$" || true)"
read -ra MERGED <<< "$MERGED_LIST"

WORKDIR="$TMPDIR/git-merged/$(basename "$PWD")"

debug "Working in $WORKDIR"

run rm -rf "$WORKDIR"
run mkdir -p "$WORKDIR"
run cp -R . "$WORKDIR/"

#trap EXIT rm -rf "$WORKDIR"

run cd "$WORKDIR" || die "Couldn't cd to $WORKDIR"

BRANCHES="$(find $GIT_DIR/refs/heads -mindepth 1 -type f | sed -E "s|^$GIT_DIR/refs/heads/(.*)\$|\1|")"

is_rebased() { local BRANCH="$1" BASE="$2" LOG
	LOG="$(git log --cherry --pretty=oneline "$BASE...$BRANCH")" || die "Unable to run git log --cherry --pretty=oneline ..."
	# Search the log for lines not beginning with "="... If there are none
	# then all commits on this branch are on the base branch so return 0.
	! grep -Ev '^=' <<< "$LOG" > /dev/null 2>&1
}

is_squashed() { local BRANCH="$1" BASE="$2"
	run git reset -q --hard HEAD --
	run git checkout -qB "git-merged/test/$BRANCH" "$BASE" --
	run git reset -q --hard "$BASE" --
	run git merge -q -m "git-merged: test: $BRANCH -> $BASE" "$BRANCH" > /dev/null 2>&1 || return 1
	DIFF_CHAR_COUNT="$(run git diff HEAD "$BASE" -- | wc -c | xargs)"
	[[ "$DIFF_CHAR_COUNT" -eq 0 ]]
}

for BRANCH in $BRANCHES; do
	# Never check main against itself...
	if [[ "$BRANCH" == "$TARGET_BRANCH" ]]; then continue; fi
	if is_in_array "$BRANCH" "${MERGED[@]}" "$TARGET_BRANCH"; then
		debug "Skipping squash-merge check of actually-merged branch $BRANCH"
		log_output "" "m $BRANCH"
		continue
	fi
	if is_rebased "$BRANCH" "$TARGET_BRANCH" ]]; then
		log_output "" "r $BRANCH"
		continue
	fi
	if is_squashed "$BRANCH" "$TARGET_BRANCH" ]]; then
		log_output "" "s $BRANCH"
		continue
	fi
	#log_output "" "u $BRANCH $(git rev-list --left-right --count $TARGET_BRANCH...$BRANCH | sed -E -e 's/^/-/' -e 's/[[:space:]]+/ \+/')"
	log_output "" "u $BRANCH"
done
